# Deployment Guide - Classic Method Gym Intelligence System

A comprehensive guide for deploying and managing the application across multiple environments on Vercel.

---

## Table of Contents

1. [Environment Strategy](#1-environment-strategy)
2. [Vercel Project Setup](#2-vercel-project-setup)
3. [Database Strategy](#3-database-strategy)
4. [Environment Variables](#4-environment-variables)
5. [Deployment Workflow](#5-deployment-workflow)
6. [Database Migrations](#6-database-migrations)
7. [Backup & Recovery](#7-backup--recovery)
8. [Rollback Procedures](#8-rollback-procedures)
9. [Monitoring & Alerts](#9-monitoring--alerts)
10. [Checklist: Before Going Live](#10-checklist-before-going-live)

---

## 1. Environment Strategy

### Why Multiple Environments?

| Risk | Without Environments | With Environments |
|------|---------------------|-------------------|
| Breaking production | High - every change goes live | Low - test in staging first |
| Data loss | Catastrophic - real user data | Contained - only test data affected |
| Debugging | Hard - affects real users | Easy - isolated environment |
| Testing migrations | Dangerous | Safe - test on staging DB first |

### Recommended Environment Setup

| Environment | Branch | Database | URL | Purpose |
|-------------|--------|----------|-----|---------|
| **LOCAL** | feature/* or fix/* | Local PostgreSQL or Docker | http://localhost:3000 | Day-to-day development |
| **PREVIEW** | Any non-main branch | Staging DB (shared) | Auto-generated by Vercel | PR reviews, quick testing |
| **STAGING** | develop | Dedicated staging PostgreSQL | https://staging.classicmethod.app | Final testing before production |
| **PRODUCTION** | main | Production PostgreSQL (with backups!) | https://classicmethod.app | Real users, real data |

**Deployment Flow:**

1. **LOCAL** → Push to branch
2. **PREVIEW** → Merge to develop
3. **STAGING** → Merge to main (after approval)
4. **PRODUCTION**

### Branch Strategy

```
main (production)
 │
 └── develop (staging)
      │
      ├── feature/add-new-metric-type
      ├── feature/coach-dashboard-redesign
      ├── fix/login-timeout-issue
      └── hotfix/critical-security-patch (→ direct to main if urgent)
```

---

## 2. Vercel Project Setup

### Option A: Single Project with Branch Environments (Recommended for Small Teams)

This approach uses one Vercel project with different branches mapped to environments.

**Step 1: Create the Vercel Project**

```bash
# Install Vercel CLI
npm install -g vercel

# Link your project
cd classic-ai
vercel link
```

**Step 2: Configure Branch Deployments**

In your Vercel Dashboard → Project Settings → Git:

| Setting | Value |
|---------|-------|
| Production Branch | `main` |
| Preview Branches | All other branches |

**Step 3: Set Up Environment-Specific Variables**

In Vercel Dashboard → Project Settings → Environment Variables:

```
# Production (main branch)
DATABASE_URL          = postgresql://...@prod-db.../gym_prod
ANTHROPIC_API_KEY     = sk-ant-prod-...
NEXT_PUBLIC_APP_URL   = https://classicmethod.app
JWT_SECRET            = <unique-production-secret>

# Preview (develop branch and PRs)
DATABASE_URL          = postgresql://...@staging-db.../gym_staging
ANTHROPIC_API_KEY     = sk-ant-staging-...
NEXT_PUBLIC_APP_URL   = https://staging.classicmethod.app
JWT_SECRET            = <unique-staging-secret>
```

**Step 4: Configure Custom Domains**

In Vercel Dashboard → Project Settings → Domains:

```
classicmethod.app           → Production (main)
staging.classicmethod.app   → Preview (develop branch)
```

### Option B: Separate Projects per Environment (Recommended for Larger Teams)

For maximum isolation, create separate Vercel projects:

```
classic-ai-production    → main branch only
classic-ai-staging       → develop branch only
```

**Pros:**
- Complete isolation (separate billing, logs, analytics)
- Different team access per environment
- No risk of accidentally deploying to wrong environment

**Cons:**
- More setup overhead
- Need to manage multiple projects

---

## 3. Database Strategy

### Database Provider Options

| Provider | Free Tier | Best For | Automatic Backups |
|----------|-----------|----------|-------------------|
| **Neon** | 0.5GB, 1 project | Development, small staging | Yes (7 days) |
| **Supabase** | 500MB, 2 projects | Full-stack, realtime needs | Yes (7 days) |
| **Railway** | $5 credit/month | Simple setup | Manual |
| **PlanetScale** | 5GB (MySQL) | High scale | Yes |
| **AWS RDS** | 12 months free tier | Enterprise | Configurable |
| **DigitalOcean** | $15/month | Production reliability | Yes |

### Recommended Database Architecture

| Environment | Database | Connection String | Notes |
|-------------|----------|-------------------|-------|
| **LOCAL** | Docker PostgreSQL or local install | `postgresql://postgres:postgres@localhost:5432/gym_dev` | For development |
| **STAGING** | Neon or Supabase (Free Tier) | `postgresql://user:pass@staging-host/gym_staging` | Contains test data, can be reset. Used for migration testing. |
| **PRODUCTION** | Supabase Pro, Neon Pro, or DigitalOcean | `postgresql://user:pass@prod-host/gym_production` | Automatic daily backups, Point-in-time recovery, Connection pooling |

### This Project's Neon Setup (Already Configured)

This project uses the **Neon Serverless Driver** with Prisma's adapter pattern. Connection pooling is handled automatically by the adapter in `lib/db/index.ts`.

**Step 1: Create Neon Account and Projects**

```bash
# Create two projects in Neon dashboard:
# 1. classic-method-staging
# 2. classic-method-production
```

**Step 2: Get Connection String**

In Neon Dashboard → Connection Details → Copy the connection string:

```
DATABASE_URL="postgresql://user:pass@ep-xxx.region.aws.neon.tech/gym_db?sslmode=require"
```

**How Connection Pooling Works (Already Implemented)**

Unlike standard Prisma setups, this project uses the `@prisma/adapter-neon` package which handles connection pooling automatically.

**Database Selection Logic (`lib/db/index.ts`):**

```typescript
// Automatically selects the right database based on environment:
// - Local development (NODE_ENV=development): DEV_DATABASE_URL
// - Vercel Preview (VERCEL_ENV=preview): STAGING_DATABASE_URL
// - Vercel Production (VERCEL_ENV=production): DATABASE_URL

const vercelEnv = process.env.VERCEL_ENV;
const isLocalDev = process.env.NODE_ENV === "development" && !vercelEnv;
const isVercelPreview = vercelEnv === "preview" || vercelEnv === "development";

const connectionString = isLocalDev
  ? process.env.DEV_DATABASE_URL || process.env.DATABASE_URL
  : isVercelPreview
    ? process.env.STAGING_DATABASE_URL || process.env.DATABASE_URL
    : process.env.DATABASE_URL;

const adapter = new PrismaNeon({
  connectionString,
  max: 10,                      // Maximum connections in pool
  idleTimeoutMillis: 30000,     // Close idle connections after 30s
  connectionTimeoutMillis: 10000 // Timeout for new connections
});
```

This means you need different DATABASE_URL variables per environment - no separate `DIRECT_DATABASE_URL` needed.

### Database Branching (Advanced - Neon Feature)

Neon supports database branching - create instant copies of your database:

```bash
# Before a risky migration:
# 1. Create a branch in Neon dashboard from production
# 2. Test migration on branch
# 3. If successful, run on production
# 4. Delete branch
```

---

## 4. Environment Variables

### Complete Variable List

See `.env.example` for the complete list of environment variables. Key variables:

```bash
# Database (Neon PostgreSQL) - Different per environment
DATABASE_URL="postgresql://user:pass@ep-xxx.region.aws.neon.tech/gym_prod?sslmode=require"
STAGING_DATABASE_URL="postgresql://user:pass@ep-xxx.region.aws.neon.tech/gym_staging?sslmode=require"
DEV_DATABASE_URL="postgresql://user:pass@localhost:5432/gym_dev"  # Local only

# Authentication (generate unique per environment!)
JWT_SECRET="minimum-32-character-secret-key-here"

# AI Services
ANTHROPIC_API_KEY="sk-ant-api03-..."

# Application URL
NEXT_PUBLIC_APP_URL="https://your-domain.com"

# Payments (Stripe)
STRIPE_SECRET_KEY="sk_test_..."
STRIPE_WEBHOOK_SECRET="whsec_..."
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="pk_test_..."
```

### Vercel Environment Variable Configuration

In Vercel Dashboard, set variables with proper scoping:

| Variable | Production | Preview | Development |
|----------|------------|---------|-------------|
| `DATABASE_URL` | prod-db-url | - | - |
| `STAGING_DATABASE_URL` | - | staging-db-url | staging-db-url |
| `JWT_SECRET` | prod-secret | staging-secret | - |
| `ANTHROPIC_API_KEY` | your-key | your-key | - |
| `NEXT_PUBLIC_APP_URL` | https://classicmethod.app | https://staging.classicmethod.app | - |

**Note:** `NODE_ENV` is automatically set by Vercel to `production` for all deployments. The app uses `VERCEL_ENV` (automatically set by Vercel) to distinguish between Production and Preview environments.

**Important:** Never share JWT_SECRET between environments! Each environment should have a unique secret.

---

## 5. Deployment Workflow

### Daily Development Flow

```bash
# 1. Create feature branch
git checkout develop
git pull origin develop
git checkout -b feature/new-feature

# 2. Develop locally
npm run dev
# Make changes, test locally

# 3. Push and create PR
git add .
git commit -m "Add new feature"
git push origin feature/new-feature
# Create PR: feature/new-feature → develop

# 4. Vercel automatically creates Preview deployment
# Test at: https://classic-ai-feature-new-feature-yourteam.vercel.app

# 5. After PR approval, merge to develop
# Staging automatically deploys to: https://staging.classicmethod.app

# 6. Test on staging with staging database

# 7. When ready, create PR: develop → main
# After approval, merge to main
# Production automatically deploys to: https://classicmethod.app
```

### Deployment Checklist

Before merging to staging (`develop`):
- [ ] All tests pass locally
- [ ] No TypeScript errors (`npm run build`)
- [ ] Feature works in Preview deployment
- [ ] Database migrations tested locally

Before merging to production (`main`):
- [ ] Feature tested on staging for at least 24 hours
- [ ] Database migrations run successfully on staging
- [ ] No errors in staging logs
- [ ] Rollback plan documented (if applicable)
- [ ] Team notified of deployment

### Automated Deployment with GitHub Actions (Optional)

Create `.github/workflows/deploy.yml`:

```yaml
name: Deploy

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run type check
        run: npx tsc --noEmit

      - name: Run linter
        run: npm run lint

      - name: Run build
        run: npm run build
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL_TEST }}

      # Add tests when you have them
      # - name: Run tests
      #   run: npm test

  notify-staging:
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Notify team
        run: echo "Staging deployment triggered"
        # Add Slack/Discord notification here

  notify-production:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Notify team
        run: echo "Production deployment triggered"
        # Add Slack/Discord notification here
```

---

## 6. Database Migrations

### Migration Safety Rules

1. **Never run untested migrations on production**
2. **Always backup before migrations**
3. **Test migrations on staging first**
4. **Make migrations reversible when possible**
5. **Deploy code before migrations that add columns**
6. **Deploy migrations before code that removes columns**

### Safe Migration Workflow

| Step | Action | Command/Notes |
|------|--------|---------------|
| 1 | **Create migration locally** | `npx prisma migrate dev --name add_new_feature` |
| 2 | **Test locally** | Verify migration applies cleanly, test app functionality, check both upgrade AND potential rollback |
| 3 | **Deploy code to staging** (without migration) | Push to develop branch, Vercel deploys to staging |
| 4 | **Run migration on staging** | `DATABASE_URL=<staging-db> npx prisma migrate deploy` |
| 5 | **Test on staging** | Full functionality test, monitor for errors (24-48 hours for significant changes) |
| 6 | **Backup production database** | Create manual backup in Neon/Supabase dashboard, or: `pg_dump production_db > backup_$(date +%Y%m%d).sql` |
| 7 | **Deploy code to production** | Merge develop → main, Vercel deploys to production |
| 8 | **Run migration on production** | `DATABASE_URL=<prod-db> npx prisma migrate deploy` |
| 9 | **Verify production** | Check logs for errors, test critical paths, monitor for 30 minutes |

### Types of Schema Changes

#### Safe Changes (Low Risk)

```prisma
// Adding a new optional column - SAFE
model Member {
  newField String?  // Nullable, no migration issues
}

// Adding a new table - SAFE
model NewFeature {
  id String @id @default(cuid())
  // ...
}

// Adding an index - SAFE (but may be slow on large tables)
@@index([newField])
```

#### Moderate Risk Changes

```prisma
// Adding a required column with default - MODERATE
model Member {
  newField String @default("default_value")
}

// Renaming a column - MODERATE (requires data migration)
// Old: firstName String
// New: name String
```

#### High Risk Changes

```prisma
// Removing a column - HIGH RISK
// - Ensure no code references it first
// - Deploy code changes BEFORE migration

// Changing column type - HIGH RISK
// - May lose data
// - Often requires multi-step migration

// Removing a table - HIGH RISK
// - Ensure complete backup
// - Verify no foreign keys reference it
```

### Running Migrations

**Local Development:**
```bash
# Create and apply migration
npx prisma migrate dev --name description_of_change

# Reset database (WARNING: destroys all data)
npx prisma migrate reset
```

**Staging/Production:**
```bash
# Apply pending migrations (does NOT create new migrations)
npx prisma migrate deploy

# Check migration status
npx prisma migrate status
```

### Prisma Migrate Deploy in Vercel

Add to `package.json`:

```json
{
  "scripts": {
    "postinstall": "prisma generate",
    "vercel-build": "prisma generate && prisma migrate deploy && next build"
  }
}
```

**Note:** This runs migrations automatically on deploy. For more control, you may want to run migrations manually before deploying code.

### Manual Migration Approach (Safer for Production)

If you prefer manual control:

```json
{
  "scripts": {
    "vercel-build": "prisma generate && next build"
  }
}
```

Then run migrations manually via CLI before deploying:

```bash
# Set production database URL temporarily
export DATABASE_URL="postgresql://..."

# Run migrations
npx prisma migrate deploy

# Then trigger Vercel deploy
git push origin main
```

---

## 7. Backup & Recovery

### Backup Strategy Overview

| Backup Type | Frequency | Retention | When to Use |
|-------------|-----------|-----------|-------------|
| **Automated Backups** (Database Provider) | Daily | 7-30 days (depends on plan) | Automatic recovery from provider dashboard |
| **Manual Backups** | Before risky operations | As needed | Before schema migrations, bulk data updates, major feature deployments |
| **Point-in-Time Recovery** (Premium) | Continuous | Varies by provider | Neon Pro: Instant branching. Supabase Pro: 7-day PITR. AWS RDS: Configurable. |

### Manual Backup Commands

```bash
# Export database to SQL file
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql

# Export specific tables only
pg_dump $DATABASE_URL -t members -t daily_logs > members_backup.sql

# Compressed backup
pg_dump $DATABASE_URL | gzip > backup_$(date +%Y%m%d).sql.gz
```

### Restore from Backup

```bash
# Restore full database (WARNING: overwrites everything)
psql $DATABASE_URL < backup_20250120.sql

# Restore to a new database first (safer)
createdb gym_restored
psql gym_restored < backup_20250120.sql
# Verify data, then swap connections
```

### Using Neon Branching for Safe Operations

```bash
# Before a risky migration:

# 1. In Neon Dashboard: Create branch from production
#    Name: pre-migration-backup-20250120

# 2. Run migration on production

# 3. If something goes wrong:
#    - Point DATABASE_URL to the branch
#    - Investigate and fix
#    - Or restore from branch

# 4. If successful:
#    - Delete the branch after 24-48 hours
```

---

## 8. Rollback Procedures

### Code Rollback (Vercel)

**Option 1: Vercel Dashboard**
1. Go to Vercel Dashboard → Deployments
2. Find the last working deployment
3. Click "..." → "Promote to Production"

**Option 2: Git Revert**
```bash
# Revert the last commit
git revert HEAD
git push origin main

# Revert a specific commit
git revert <commit-hash>
git push origin main

# Hard reset (use with caution)
git reset --hard <known-good-commit>
git push --force origin main  # DANGEROUS: rewrites history
```

### Database Rollback

**If migration can be reversed:**
```bash
# Prisma doesn't have built-in rollback, but you can:

# 1. Create a new migration that undoes the change
npx prisma migrate dev --name revert_previous_change

# 2. Apply it
npx prisma migrate deploy
```

**If migration cannot be reversed:**
```bash
# 1. Restore from backup
psql $DATABASE_URL < backup_before_migration.sql

# 2. Mark migrations as rolled back
# (You may need to manually update _prisma_migrations table)

# 3. Redeploy previous code version
```

### Rollback Decision Tree

**Is the issue critical (data loss, security, complete outage)?**

- **YES → Immediate rollback**
  - Revert code via Vercel dashboard
  - Restore database from backup if needed
  - Notify team immediately

- **NO → Assess and plan**
  - Can it be fixed forward quickly (< 1 hour)?
    - YES → Deploy hotfix
    - NO → Rollback and investigate
  - Is it affecting users significantly?
    - YES → Rollback
    - NO → Fix in next deployment cycle

---

## 9. Monitoring & Alerts

### Vercel Built-in Monitoring

- **Analytics**: Page views, performance metrics
- **Logs**: Runtime logs (Functions → Logs)
- **Speed Insights**: Core Web Vitals

### Recommended: Add Error Tracking (Sentry)

**Step 1: Install Sentry**
```bash
npm install @sentry/nextjs
npx @sentry/wizard@latest -i nextjs
```

**Step 2: Configure Sentry**
```javascript
// sentry.client.config.js
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1, // 10% of transactions

  // Only send errors in production
  enabled: process.env.NODE_ENV === "production",
});
```

**Step 3: Set Environment Variables**
```
NEXT_PUBLIC_SENTRY_DSN=https://...@sentry.io/...
SENTRY_AUTH_TOKEN=... (for source maps)
```

### Health Check Endpoint

Already created at `app/api/health/route.ts`. This endpoint checks database connectivity and returns system status.

### Uptime Monitoring (Free Options)

| Service | Free Tier |
|---------|-----------|
| **UptimeRobot** | 50 monitors, 5-min intervals |
| **Checkly** | 5 checks, 10-min intervals |
| **Better Uptime** | 10 monitors |

Configure to ping:
- `https://classicmethod.app/api/health`
- `https://staging.classicmethod.app/api/health`

---

## 10. Checklist: Before Going Live

### Infrastructure Setup

- [ ] **Production database** created with:
  - [ ] Automatic daily backups enabled
  - [ ] Connection pooling enabled
  - [ ] SSL/TLS enforced
- [ ] **Staging database** created (separate from production)
- [ ] **Vercel project** configured with:
  - [ ] Custom domain connected
  - [ ] SSL certificate active
  - [ ] Environment variables set for all environments
- [ ] **DNS** configured correctly:
  - [ ] A/CNAME records pointing to Vercel
  - [ ] www redirect configured (if needed)

### Security

- [ ] **Unique secrets** per environment:
  - [ ] JWT_SECRET is different for staging/production
  - [ ] At least 32 characters, randomly generated
- [ ] **API keys** secured:
  - [ ] Anthropic API key has spending limits
  - [ ] Stripe keys are correct (test vs live)
- [ ] **No secrets in code**:
  - [ ] `.env` is in `.gitignore`
  - [ ] No hardcoded credentials
- [ ] **Headers configured** (in `next.config.js`):
  - [ ] HTTPS enforced
  - [ ] Security headers (CSP, HSTS, etc.)

### Application

- [ ] **Build succeeds** without errors
- [ ] **All pages load** correctly
- [ ] **Authentication works**:
  - [ ] Member login
  - [ ] Staff login
  - [ ] Session persistence
  - [ ] Logout
- [ ] **Critical features tested**:
  - [ ] Meal logging
  - [ ] Training logging
  - [ ] AI chat
  - [ ] Weekly check-in
- [ ] **Error handling** works (try triggering errors)

### Monitoring

- [ ] **Error tracking** configured (Sentry or similar)
- [ ] **Uptime monitoring** configured
- [ ] **Health check endpoint** responding
- [ ] **Alerts** configured (email/Slack for downtime)

### Documentation

- [ ] **Environment variables** documented
- [ ] **Deployment process** documented (this guide!)
- [ ] **Rollback procedure** understood by team
- [ ] **On-call contacts** defined

### Final Verification

- [ ] Test full user journey on staging
- [ ] Load test if expecting significant traffic
- [ ] Verify backup can be restored
- [ ] Team briefed on go-live plan

---

## Quick Reference Commands

```bash
# ============================================
# LOCAL DEVELOPMENT
# ============================================
npm run dev                          # Start dev server
npx prisma studio                    # Database GUI
npx prisma migrate dev --name xyz    # Create migration

# ============================================
# STAGING DEPLOYMENT
# ============================================
git push origin develop              # Auto-deploys to staging

# Run migration on staging
DATABASE_URL="staging-url" npx prisma migrate deploy

# ============================================
# PRODUCTION DEPLOYMENT
# ============================================
# 1. Backup first!
pg_dump $PROD_DATABASE_URL > backup_$(date +%Y%m%d).sql

# 2. Run migration on production
DATABASE_URL="prod-url" npx prisma migrate deploy

# 3. Deploy code
git checkout main
git merge develop
git push origin main                 # Auto-deploys to production

# ============================================
# EMERGENCY ROLLBACK
# ============================================
# Via Vercel Dashboard: Deployments → Previous → Promote to Production

# Via Git:
git revert HEAD
git push origin main

# ============================================
# DATABASE RESTORE
# ============================================
psql $DATABASE_URL < backup_file.sql
```

---

## Summary

| Environment | Branch | Database | Purpose |
|-------------|--------|----------|---------|
| Local | feature/* | Local PostgreSQL | Development |
| Preview | PR branches | Staging DB | PR reviews |
| Staging | develop | Staging DB | Final testing |
| Production | main | Production DB | Live users |

**Golden Rules:**
1. Never deploy untested code to production
2. Always backup before migrations
3. Test migrations on staging first
4. Have a rollback plan ready
5. Monitor after every deployment

---

*Last updated: January 2026*
